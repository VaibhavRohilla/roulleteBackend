import TelegramBot from 'node-telegram-bot-api';
import { CONFIG } from '../config/config';
import { Logger } from '../utils/Logger';
import { SupabaseService } from '../services/SupabaseService';
import { GameStateManager, GameState, GameStateResponse } from '../services/GameStateManager';
import { TimeUtils } from '../utils/TimeUtils';
import { isValidRouletteNumber, getRouletteColor, getRouletteParity } from '../utils/RouletteUtils';

export const spinQueue: number[] = [];

// Track spin IDs for database operations
export const spinIdMap: Map<number, string[]> = new Map(); // spin_number -> array of spin IDs

export class TelegramBotService {
  public bot: TelegramBot;
  private auditService: SupabaseService;
  private gameStateManager: GameStateManager;

  constructor() {
    this.bot = new TelegramBot(CONFIG.TELEGRAM_BOT_TOKEN, { polling: true });
    this.auditService = SupabaseService.getInstance();
    this.gameStateManager = GameStateManager.getInstance();
    this.setupHandlers();
    this.logBotStart();
  }

  private isAdmin(userId: number): boolean {
    return CONFIG.ADMINS.includes(userId);
  }

  private setupHandlers() {
    // Add spin to queue
    this.bot.onText(/spin\s*:\s*(\d+)/i, async (msg, match) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';
      const index = parseInt(match![1]);

      if (!this.isAdmin(userId)) {
        Logger.warn(`üö® Unauthorized spin from ${username} (${userId}): ${msg.text}`);
        this.bot.sendMessage(msg.chat.id, `‚ùå **Not Authorized**\n\nUser: @${username}\nAction: Add spin ${index}\nStatus: DENIED\n\nOnly authorized admins can control the roulette.`);
        await this.logAction(userId, username, 'add_spin_unauthorized', `Attempted to add spin: ${index}`, null, null, false);
        return;
      }

      if (!isValidRouletteNumber(index)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Invalid Spin Number**\n\nInput: ${index}\nValid Range: 0-36\nUser: @${username}\n\nPlease use a number between 0 and 36 for European Roulette.`);
        await this.logAction(userId, username, 'add_spin_invalid', `Invalid spin number: ${index}`, null, null, false);
        return;
      }

      const oldQueue = [...spinQueue];
      
      // Check queue size limit to prevent memory issues
      if (spinQueue.length >= CONFIG.MAX_SPIN_QUEUE_SIZE) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Queue Full**\n\nüìã Current Queue: ${spinQueue.length}/${CONFIG.MAX_SPIN_QUEUE_SIZE}\nüë§ User: @${username}\n\nThe spin queue is full. Please wait for current spins to be processed.`);
        await this.logAction(userId, username, 'add_spin_queue_full', `Queue full: ${spinQueue.length}/${CONFIG.MAX_SPIN_QUEUE_SIZE}`, null, null, false);
        return;
      }

      // Store spin in database immediately when command is received
      const spinId = await this.storeSpinResult(index);
      
      // Refresh last spin cache since we added a new spin
      if (spinId) {
        await this.gameStateManager.refreshLastSpinCache();
      }
      
      spinQueue.push(index);
      const gameState = this.gameStateManager.getGameStateResponse();
      
      // Track spin ID for potential deletion
      if (spinId) {
        if (!spinIdMap.has(index)) {
          spinIdMap.set(index, []);
        }
        spinIdMap.get(index)!.push(spinId);
      }
      
      // If game is idle (no active round, no spinning), start a new round
      if (!gameState.roundActive && !gameState.isSpinning && this.gameStateManager.isRunning()) {
        console.log('üöÄ Game was idle, starting new round due to queued spin');
        this.gameStateManager.startNewRound();
      }
      
      const storageStatus = spinId ? '‚úÖ Stored in DB' : '‚ö†Ô∏è DB storage failed';
      this.bot.sendMessage(msg.chat.id, `‚úÖ **Spin Queued Successfully**\n\nüéØ Number: ${index}\nüë§ Added by: @${username}\nüìã Queue Position: ${spinQueue.length}\nüìä Total in Queue: ${spinQueue.length}\nüíæ Database: ${storageStatus}\nüéÆ Game State: ${gameState.roundActive ? 'üéØ Round Active' : gameState.isSpinning ? 'üé∞ Spinning' : 'üí§ Idle'}\n\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
      await this.logAction(userId, username, 'add_spin', `Added spin: ${index} (DB: ${spinId ? 'stored' : 'failed'})`, oldQueue, [...spinQueue], true);
    });

    // Game Status
    this.bot.onText(/\/status/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';
      
      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /status\nStatus: UNAUTHORIZED\n\nOnly admins can view game status.`);
        return;
      }
      
      const gameState = this.gameStateManager.getGameStateResponse();
      const statusMessage = `üìä **ROULETTE GAME STATUS**\n\n` +
        `üéÆ Game State: ${this.gameStateManager.getState().toUpperCase()}\n` +
        `üéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\n` +
        `üé∞ Currently Spinning: ${gameState.isSpinning ? 'YES' : 'NO'}\n` +
        `üìã Queue Length: ${spinQueue.length} spins\n` +
        `üìù Queued Numbers: [${spinQueue.join(', ') || 'empty'}]\n` +
        `‚è∞ Round Duration: ${gameState.roundDuration || 0}ms\n` +
        `üïí Last Update: ${TimeUtils.getIndianTimeString()}\n` +
        `üë§ Requested by: @${username}`;
        
      this.bot.sendMessage(msg.chat.id, statusMessage);
      await this.logAction(userId, username, 'check_status', 'Checked game status', null, null, true);
    });

    // Clear queue (legacy command - kept for compatibility)
    this.bot.onText(/\/clear/, async (msg) => {
      await this.handleDeleteQueue(msg);
    });

    // Delete entire queue
    this.bot.onText(/\/delete_queue/, async (msg) => {
      await this.handleDeleteQueue(msg);
    });

    // Delete specific value from queue
    this.bot.onText(/\/delete\s+(\d+)/, async (msg, match) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';
      const valueToDelete = parseInt(match![1]);

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /delete ${valueToDelete}\nStatus: UNAUTHORIZED\n\nOnly admins can modify the queue.`);
        return;
      }

      const oldQueue = [...spinQueue];
      const initialLength = spinQueue.length;
      
      // Remove all instances of the value
      for (let i = spinQueue.length - 1; i >= 0; i--) {
        if (spinQueue[i] === valueToDelete) {
          spinQueue.splice(i, 1);
        }
      }

      const deletedCount = initialLength - spinQueue.length;
      if (deletedCount > 0) {
        // Mark deleted spins in database
        await this.markSpinsAsDeleted(valueToDelete, deletedCount);
        
        this.bot.sendMessage(msg.chat.id, `‚úÖ **Value Deleted Successfully**\n\nüéØ Number: ${valueToDelete}\nüóëÔ∏è Instances Removed: ${deletedCount}\nüìã Queue Length: ${initialLength} ‚Üí ${spinQueue.length}\nüìù Remaining Queue: [${spinQueue.join(', ') || 'empty'}]\nüíæ Database: Updated (marked as deleted)\nüë§ Deleted by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
        await this.logAction(userId, username, 'delete_value', `Deleted value: ${valueToDelete} (${deletedCount} instances, marked in DB)`, oldQueue, [...spinQueue], true);
      } else {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Value Not Found**\n\nüéØ Number: ${valueToDelete}\nüìã Current Queue: [${spinQueue.join(', ') || 'empty'}]\nüìä Queue Length: ${spinQueue.length}\nüë§ Attempted by: @${username}\n\nThe number ${valueToDelete} was not found in the queue.`);
        await this.logAction(userId, username, 'delete_value_not_found', `Value not found: ${valueToDelete}`, oldQueue, [...spinQueue], false);
      }
    });

    // Resume game
    this.bot.onText(/\/resume/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /resume\nStatus: UNAUTHORIZED\n\nOnly admins can control game state.`);
        return;
      }

      const oldState = this.gameStateManager.getState();
      const success = this.gameStateManager.resume();
      if (success) {
        const gameState = this.gameStateManager.getGameStateResponse();
        this.bot.sendMessage(msg.chat.id, `‚úÖ **Game Resumed Successfully**\n\n‚ñ∂Ô∏è Status: RUNNING\nüéÆ Previous State: ${oldState.toUpperCase()}\nüìã Queue Length: ${spinQueue.length}\nüéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\nüë§ Resumed by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
        await this.logAction(userId, username, 'resume_game', 'Game resumed', oldState, GameState.RUNNING, true);
      } else {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Resume Failed**\n\nüéÆ Current State: ${oldState.toUpperCase()}\nüìù Reason: Game is already running\nüë§ Attempted by: @${username}\n\nThe game is already in running state.`);
        await this.logAction(userId, username, 'resume_game_failed', 'Game already running', oldState, this.gameStateManager.getState(), false);
      }
    });

    // Pause/Stop game
    this.bot.onText(/\/stop/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /stop\nStatus: UNAUTHORIZED\n\nOnly admins can control game state.`);
        return;
      }

      const oldState = this.gameStateManager.getState();
      const success = this.gameStateManager.pause();
      if (success) {
        const gameState = this.gameStateManager.getGameStateResponse();
        this.bot.sendMessage(msg.chat.id, `‚úÖ **Game Paused Successfully**\n\n‚è∏Ô∏è Status: PAUSED\nüéÆ Previous State: ${oldState.toUpperCase()}\nüìã Queue Length: ${spinQueue.length}\nüéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\nüë§ Paused by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}\n\nUse /resume to continue the game.`);
        await this.logAction(userId, username, 'pause_game', 'Game paused', oldState, GameState.PAUSED, true);
      } else {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Pause Failed**\n\nüéÆ Current State: ${oldState.toUpperCase()}\nüìù Reason: Game is already paused\nüë§ Attempted by: @${username}\n\nThe game is already in paused state.`);
        await this.logAction(userId, username, 'pause_game_failed', 'Game already paused', oldState, this.gameStateManager.getState(), false);
      }
    });

    // Reset everything
    this.bot.onText(/\/reset/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /reset\nStatus: UNAUTHORIZED\n\nOnly admins can reset the game.`);
        return;
      }

      const oldQueue = [...spinQueue];
      const oldState = this.gameStateManager.getState();
      
      this.gameStateManager.reset();
      const gameState = this.gameStateManager.getGameStateResponse();
      
      this.bot.sendMessage(msg.chat.id, `‚úÖ **Game Reset Successfully**\n\nüîÑ Action: FULL RESET\nüéÆ Game State: RUNNING\nüìã Queue: CLEARED (was ${oldQueue.length} items)\nüéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\nüìù Previous Queue: [${oldQueue.join(', ') || 'empty'}]\nüë§ Reset by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}\n\nGame is now ready for new rounds!`);
      await this.logAction(userId, username, 'reset_game', 'Full game reset', { queue: oldQueue, state: oldState }, { queue: [], state: GameState.RUNNING }, true);
    });

    // View recent spin results
    this.bot.onText(/\/results\s*(\d*)/, async (msg, match) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /results\nStatus: UNAUTHORIZED\n\nOnly admins can view spin results.`);
        return;
      }

      try {
        const limit = parseInt(match![1]) || 5;
        const maxLimit = 10;
        const actualLimit = Math.min(limit, maxLimit);
        
        const results = await this.auditService.getLastSpinResults(actualLimit);
        
        if (results.length === 0) {
          this.bot.sendMessage(msg.chat.id, `üìä **No Spin Results Found**\n\nüìã Recent spin results: 0\nüë§ Requested by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}\n\nNo spin results are stored in the database yet.`);
          return;
        }

        let resultText = `üìä **RECENT SPIN RESULTS (${results.length})**\n\n`;
        results.forEach((result, index) => {
          const resultTime = result.timestamp ? new Date(result.timestamp).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' }) : 'Unknown time';
          resultText += `${index + 1}. üéØ **${result.spin_number}** ${result.color} ${result.parity}\n   üìÖ ${resultTime}\n\n`;
        });

        resultText += `üë§ **Requested by:** @${username}\n‚è∞ **Generated at:** ${TimeUtils.getIndianTimeString()}`;

        this.bot.sendMessage(msg.chat.id, resultText);
        await this.logAction(userId, username, 'view_results', `Viewed ${results.length} recent spin results`, null, null, true);
      } catch (error) {
        Logger.error(`‚ùå Error fetching spin results: ${error}`);
        this.bot.sendMessage(msg.chat.id, `‚ùå **Error Fetching Results**\n\nüìä Failed to retrieve spin results\nüìù Error: Database connection issue\nüë§ Requested by: @${username}\n\nPlease try again later or contact support.`);
        await this.logAction(userId, username, 'view_results_error', `Error fetching results: ${error}`, null, null, false);
      }
    });

    // Help command
    this.bot.onText(/\/help/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /help\nStatus: UNAUTHORIZED\n\nOnly authorized admins can access help.`);
        return;
      }

      const gameState = this.gameStateManager.getGameStateResponse();
      const helpMessage = `üé∞ **API-DRIVEN ROULETTE BOT**

üìã **QUEUE MANAGEMENT:**
‚Ä¢ \`spin: <0-36>\` - Add number to spin queue
‚Ä¢ \`/status\` - Show detailed game status
‚Ä¢ \`/delete_queue\` - Clear entire queue
‚Ä¢ \`/delete <number>\` - Remove specific number

üéÆ **GAME CONTROL:**
‚Ä¢ \`/resume\` - Resume paused game
‚Ä¢ \`/stop\` - Pause game rounds
‚Ä¢ \`/reset\` - Full reset (queue + state)

üìä **DATA & RESULTS:**
‚Ä¢ \`/results [limit]\` - View recent spin results (max 10)

‚ÑπÔ∏è **CURRENT STATUS:**
üéÆ Game State: ${this.gameStateManager.getState().toUpperCase()}
üéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}
üé∞ Spinning: ${gameState.isSpinning ? 'YES' : 'NO'}
üìã Queue Length: ${spinQueue.length}

üîß **SYSTEM INFO:**
‚Ä¢ API-driven polling system (no WebSocket)
‚Ä¢ Round Duration: ${gameState.roundDuration}ms
‚Ä¢ Admin-only access with full audit logging
‚Ä¢ Real-time state synchronization

üë§ **Help requested by:** @${username}
‚è∞ **Generated at:** ${TimeUtils.getIndianTimeString()}`;

      this.bot.sendMessage(msg.chat.id, helpMessage);
      await this.logAction(userId, username, 'help_requested', 'Viewed help message', null, null, true);
    });

    console.log('ü§ñ Telegram bot handlers configured');
  }

  /**
   * Store spin result to database when command is received
   */
  public async storeSpinResult(spinNumber: number): Promise<string | null> {
    // Check if Supabase is configured
    if (!this.auditService.isConfigured()) {
      console.warn(`‚ö†Ô∏è Supabase not configured, skipping storage for spin: ${spinNumber}`);
      return null;
    }

    const maxRetries = 3;
    let attempts = 0;

    while (attempts < maxRetries) {
      try {
        // Calculate roulette properties for the winning number
        const color = getRouletteColor(spinNumber);
        const parity = getRouletteParity(spinNumber);
        
        console.log(`üíæ Storing spin on command (attempt ${attempts + 1}/${maxRetries}): ${spinNumber} ${color} ${parity}`);
        
        const success = await this.auditService.storeSpinResult(spinNumber, color, parity);
        
        if (success) {
          console.log(`‚úÖ Spin stored on Telegram command: ${spinNumber} ${color} ${parity}`);
          // Note: We can't get the ID from the current implementation, but we track by number
          return `${spinNumber}-${Date.now()}`; // Generate a tracking ID
        } else {
          throw new Error(`Supabase returned false for spin ${spinNumber}`);
        }
      } catch (error) {
        attempts++;
        Logger.error(`‚ùå Error storing spin on command (attempt ${attempts}/${maxRetries}): ${error}`);
        
        if (attempts >= maxRetries) {
          Logger.error(`‚ùå Failed to store spin after ${maxRetries} attempts: ${spinNumber}`);
          return null; // Return null on failure
        } else {
          // Wait before retrying (exponential backoff)
          const delay = Math.pow(2, attempts) * 1000; // 2s, 4s, 8s
          console.log(`‚è≥ Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    return null;
  }

  /**
   * Mark spins as deleted in database when removed from queue
   */
  public async markSpinsAsDeleted(spinNumber: number, deletedCount: number): Promise<void> {
    if (!this.auditService.isConfigured()) {
      console.warn(`‚ö†Ô∏è Supabase not configured, skipping deletion marking for spin: ${spinNumber}`);
      return;
    }

    try {
      // Get recent spin results and mark matching ones as deleted
      const recentSpins = await this.auditService.getLastSpinResults(50, false); // Get last 50 active spins
      const matchingSpins = recentSpins.filter(spin => spin.spin_number === spinNumber).slice(0, deletedCount);
      
      for (const spin of matchingSpins) {
        if (spin.id) {
          await this.auditService.softDeleteSpinResult(spin.id);
          console.log(`üóëÔ∏è Marked spin as deleted in DB: ${spin.id} (${spinNumber})`);
        }
      }
      
      console.log(`‚úÖ Marked ${matchingSpins.length} instances of spin ${spinNumber} as deleted`);
    } catch (error) {
      Logger.error(`‚ùå Error marking spins as deleted: ${error}`);
    }
  }

  /**
   * Handle delete queue command
   */
  private async handleDeleteQueue(msg: any): Promise<void> {
    const userId = msg.from!.id;
    const username = msg.from?.username || msg.from?.first_name || 'Unknown';

    if (!this.isAdmin(userId)) {
      this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: Queue Clear\nStatus: UNAUTHORIZED\n\nOnly admins can clear the queue.`);
      return;
    }

    const oldQueue = [...spinQueue];
    const queueLength = spinQueue.length;
    
    // Mark all queued spins as deleted in database
    if (queueLength > 0) {
      for (const spinNumber of oldQueue) {
        const count = oldQueue.filter(n => n === spinNumber).length;
        await this.markSpinsAsDeleted(spinNumber, count);
      }
    }
    
    spinQueue.length = 0;
    
    if (queueLength > 0) {
      this.bot.sendMessage(msg.chat.id, `‚úÖ **Queue Cleared Successfully**\n\nüóëÔ∏è Action: QUEUE CLEARED\nüìã Items Removed: ${queueLength}\nüìù Cleared Numbers: [${oldQueue.join(', ')}]\nüíæ Database: All spins marked as deleted\nüìä New Queue Length: 0\nüë§ Cleared by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
    } else {
      this.bot.sendMessage(msg.chat.id, `‚ÑπÔ∏è **Queue Already Empty**\n\nüìã Current Queue Length: 0\nüë§ Attempted by: @${username}\n\nThe queue was already empty.`);
    }
    
    await this.logAction(userId, username, 'clear_queue', 'Queue cleared and marked in DB', oldQueue, [], true);
  }

  /**
   * Log bot startup
   */
  private async logBotStart(): Promise<void> {
    console.log('ü§ñ Telegram Bot Service started');
    await this.logAction(0, 'System', 'bot_start', 'Telegram bot service started', null, null, true);
  }

  /**
   * Log action to audit system
   */
  private async logAction(
    userId: number,
    username: string,
    action: string,
    details: string,
    oldValue: any,
    newValue: any,
    success: boolean
  ): Promise<void> {
    await this.auditService.logAction({
      user_id: userId,
      username,
      action,
      details,
      old_value: oldValue,
      new_value: newValue,
      success
    });
  }
}
