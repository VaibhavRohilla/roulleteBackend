import TelegramBot from 'node-telegram-bot-api';
import { CONFIG } from '../config/config';
import { Logger } from '../utils/Logger';
import { SupabaseService } from '../services/SupabaseService';
import { GameStateManager, GameState, GameStateResponse } from '../services/GameStateManager';
import { TimeUtils } from '../utils/TimeUtils';
import { isValidRouletteNumber } from '../utils/RouletteUtils';

export const spinQueue: number[] = [];

export class TelegramBotService {
  public bot: TelegramBot;
  private auditService: SupabaseService;
  private gameStateManager: GameStateManager;

  constructor() {
    this.bot = new TelegramBot(CONFIG.TELEGRAM_BOT_TOKEN, { polling: true });
    this.auditService = SupabaseService.getInstance();
    this.gameStateManager = GameStateManager.getInstance();
    this.setupHandlers();
    this.logBotStart();
  }

  private isAdmin(userId: number): boolean {
    return CONFIG.ADMINS.includes(userId);
  }

  private setupHandlers() {
    // Add spin to queue
    this.bot.onText(/spin\s*:\s*(\d+)/i, async (msg, match) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';
      const index = parseInt(match![1]);

      if (!this.isAdmin(userId)) {
        Logger.warn(`üö® Unauthorized spin from ${username} (${userId}): ${msg.text}`);
        this.bot.sendMessage(msg.chat.id, `‚ùå **Not Authorized**\n\nUser: @${username}\nAction: Add spin ${index}\nStatus: DENIED\n\nOnly authorized admins can control the roulette.`);
        await this.logAction(userId, username, 'add_spin_unauthorized', `Attempted to add spin: ${index}`, null, null, false);
        return;
      }

      if (!isValidRouletteNumber(index)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Invalid Spin Number**\n\nInput: ${index}\nValid Range: 0-36\nUser: @${username}\n\nPlease use a number between 0 and 36 for European Roulette.`);
        await this.logAction(userId, username, 'add_spin_invalid', `Invalid spin number: ${index}`, null, null, false);
        return;
      }

      const oldQueue = [...spinQueue];
      spinQueue.push(index);
      const gameState = this.gameStateManager.getGameStateResponse();
      
      // If game is idle (no active round, no spinning), start a new round
      if (!gameState.roundActive && !gameState.isSpinning && this.gameStateManager.isRunning()) {
        console.log('üöÄ Game was idle, starting new round due to queued spin');
        this.gameStateManager.startNewRound();
      }
      
      this.bot.sendMessage(msg.chat.id, `‚úÖ **Spin Queued Successfully**\n\nüéØ Number: ${index}\nüë§ Added by: @${username}\nüìã Queue Position: ${spinQueue.length}\nüìä Total in Queue: ${spinQueue.length}\nüéÆ Game State: ${gameState.roundActive ? 'üéØ Round Active' : gameState.isSpinning ? 'üé∞ Spinning' : 'üí§ Idle'}\n\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
      await this.logAction(userId, username, 'add_spin', `Added spin: ${index}`, oldQueue, [...spinQueue], true);
    });

    // Game Status
    this.bot.onText(/\/status/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';
      
      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /status\nStatus: UNAUTHORIZED\n\nOnly admins can view game status.`);
        return;
      }
      
      const gameState = this.gameStateManager.getGameStateResponse();
      const statusMessage = `üìä **ROULETTE GAME STATUS**\n\n` +
        `üéÆ Game State: ${this.gameStateManager.getState().toUpperCase()}\n` +
        `üéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\n` +
        `üé∞ Currently Spinning: ${gameState.isSpinning ? 'YES' : 'NO'}\n` +
        `üìã Queue Length: ${spinQueue.length} spins\n` +
        `üìù Queued Numbers: [${spinQueue.join(', ') || 'empty'}]\n` +
        `‚è∞ Round Duration: ${gameState.roundDuration || 0}ms\n` +
        `üïí Last Update: ${TimeUtils.getIndianTimeString()}\n` +
        `üë§ Requested by: @${username}`;
        
      this.bot.sendMessage(msg.chat.id, statusMessage);
      await this.logAction(userId, username, 'check_status', 'Checked game status', null, null, true);
    });

    // Clear queue (legacy command - kept for compatibility)
    this.bot.onText(/\/clear/, async (msg) => {
      await this.handleDeleteQueue(msg);
    });

    // Delete entire queue
    this.bot.onText(/\/delete_queue/, async (msg) => {
      await this.handleDeleteQueue(msg);
    });

    // Delete specific value from queue
    this.bot.onText(/\/delete\s+(\d+)/, async (msg, match) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';
      const valueToDelete = parseInt(match![1]);

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /delete ${valueToDelete}\nStatus: UNAUTHORIZED\n\nOnly admins can modify the queue.`);
        return;
      }

      const oldQueue = [...spinQueue];
      const initialLength = spinQueue.length;
      
      // Remove all instances of the value
      for (let i = spinQueue.length - 1; i >= 0; i--) {
        if (spinQueue[i] === valueToDelete) {
          spinQueue.splice(i, 1);
        }
      }

      const deletedCount = initialLength - spinQueue.length;
      if (deletedCount > 0) {
        this.bot.sendMessage(msg.chat.id, `‚úÖ **Value Deleted Successfully**\n\nüéØ Number: ${valueToDelete}\nüóëÔ∏è Instances Removed: ${deletedCount}\nüìã Queue Length: ${initialLength} ‚Üí ${spinQueue.length}\nüìù Remaining Queue: [${spinQueue.join(', ') || 'empty'}]\nüë§ Deleted by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
        await this.logAction(userId, username, 'delete_value', `Deleted value: ${valueToDelete} (${deletedCount} instances)`, oldQueue, [...spinQueue], true);
      } else {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Value Not Found**\n\nüéØ Number: ${valueToDelete}\nüìã Current Queue: [${spinQueue.join(', ') || 'empty'}]\nüìä Queue Length: ${spinQueue.length}\nüë§ Attempted by: @${username}\n\nThe number ${valueToDelete} was not found in the queue.`);
        await this.logAction(userId, username, 'delete_value_not_found', `Value not found: ${valueToDelete}`, oldQueue, [...spinQueue], false);
      }
    });

    // Resume game
    this.bot.onText(/\/resume/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /resume\nStatus: UNAUTHORIZED\n\nOnly admins can control game state.`);
        return;
      }

      const oldState = this.gameStateManager.getState();
      const success = this.gameStateManager.resume();
      if (success) {
        const gameState = this.gameStateManager.getGameStateResponse();
        this.bot.sendMessage(msg.chat.id, `‚úÖ **Game Resumed Successfully**\n\n‚ñ∂Ô∏è Status: RUNNING\nüéÆ Previous State: ${oldState.toUpperCase()}\nüìã Queue Length: ${spinQueue.length}\nüéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\nüë§ Resumed by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
        await this.logAction(userId, username, 'resume_game', 'Game resumed', oldState, GameState.RUNNING, true);
      } else {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Resume Failed**\n\nüéÆ Current State: ${oldState.toUpperCase()}\nüìù Reason: Game is already running\nüë§ Attempted by: @${username}\n\nThe game is already in running state.`);
        await this.logAction(userId, username, 'resume_game_failed', 'Game already running', oldState, this.gameStateManager.getState(), false);
      }
    });

    // Pause/Stop game
    this.bot.onText(/\/stop/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /stop\nStatus: UNAUTHORIZED\n\nOnly admins can control game state.`);
        return;
      }

      const oldState = this.gameStateManager.getState();
      const success = this.gameStateManager.pause();
      if (success) {
        const gameState = this.gameStateManager.getGameStateResponse();
        this.bot.sendMessage(msg.chat.id, `‚úÖ **Game Paused Successfully**\n\n‚è∏Ô∏è Status: PAUSED\nüéÆ Previous State: ${oldState.toUpperCase()}\nüìã Queue Length: ${spinQueue.length}\nüéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\nüë§ Paused by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}\n\nUse /resume to continue the game.`);
        await this.logAction(userId, username, 'pause_game', 'Game paused', oldState, GameState.PAUSED, true);
      } else {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Pause Failed**\n\nüéÆ Current State: ${oldState.toUpperCase()}\nüìù Reason: Game is already paused\nüë§ Attempted by: @${username}\n\nThe game is already in paused state.`);
        await this.logAction(userId, username, 'pause_game_failed', 'Game already paused', oldState, this.gameStateManager.getState(), false);
      }
    });

    // Reset everything
    this.bot.onText(/\/reset/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /reset\nStatus: UNAUTHORIZED\n\nOnly admins can reset the game.`);
        return;
      }

      const oldQueue = [...spinQueue];
      const oldState = this.gameStateManager.getState();
      
      this.gameStateManager.reset();
      const gameState = this.gameStateManager.getGameStateResponse();
      
      this.bot.sendMessage(msg.chat.id, `‚úÖ **Game Reset Successfully**\n\nüîÑ Action: FULL RESET\nüéÆ Game State: RUNNING\nüìã Queue: CLEARED (was ${oldQueue.length} items)\nüéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}\nüìù Previous Queue: [${oldQueue.join(', ') || 'empty'}]\nüë§ Reset by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}\n\nGame is now ready for new rounds!`);
      await this.logAction(userId, username, 'reset_game', 'Full game reset', { queue: oldQueue, state: oldState }, { queue: [], state: GameState.RUNNING }, true);
    });

    // Help command
    this.bot.onText(/\/help/, async (msg) => {
      const userId = msg.from!.id;
      const username = msg.from?.username || msg.from?.first_name || 'Unknown';

      if (!this.isAdmin(userId)) {
        this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: /help\nStatus: UNAUTHORIZED\n\nOnly authorized admins can access help.`);
        return;
      }

      const gameState = this.gameStateManager.getGameStateResponse();
      const helpMessage = `üé∞ **API-DRIVEN ROULETTE BOT**

üìã **QUEUE MANAGEMENT:**
‚Ä¢ \`spin: <0-36>\` - Add number to spin queue
‚Ä¢ \`/status\` - Show detailed game status
‚Ä¢ \`/delete_queue\` - Clear entire queue
‚Ä¢ \`/delete <number>\` - Remove specific number

üéÆ **GAME CONTROL:**
‚Ä¢ \`/resume\` - Resume paused game
‚Ä¢ \`/stop\` - Pause game rounds
‚Ä¢ \`/reset\` - Full reset (queue + state)

‚ÑπÔ∏è **CURRENT STATUS:**
üéÆ Game State: ${this.gameStateManager.getState().toUpperCase()}
üéØ Round Active: ${gameState.roundActive ? 'YES' : 'NO'}
üé∞ Spinning: ${gameState.isSpinning ? 'YES' : 'NO'}
üìã Queue Length: ${spinQueue.length}

üîß **SYSTEM INFO:**
‚Ä¢ API-driven polling system (no WebSocket)
‚Ä¢ Round Duration: ${gameState.roundDuration}ms
‚Ä¢ Admin-only access with full audit logging
‚Ä¢ Real-time state synchronization

üë§ **Help requested by:** @${username}
‚è∞ **Generated at:** ${TimeUtils.getIndianTimeString()}`;

      this.bot.sendMessage(msg.chat.id, helpMessage);
      await this.logAction(userId, username, 'help_requested', 'Viewed help message', null, null, true);
    });

    console.log('ü§ñ Telegram bot handlers configured');
  }

  /**
   * Handle delete queue command
   */
  private async handleDeleteQueue(msg: any): Promise<void> {
    const userId = msg.from!.id;
    const username = msg.from?.username || msg.from?.first_name || 'Unknown';

    if (!this.isAdmin(userId)) {
      this.bot.sendMessage(msg.chat.id, `‚ùå **Access Denied**\n\nUser: @${username}\nCommand: Queue Clear\nStatus: UNAUTHORIZED\n\nOnly admins can clear the queue.`);
      return;
    }

    const oldQueue = [...spinQueue];
    const queueLength = spinQueue.length;
    spinQueue.length = 0;
    
    if (queueLength > 0) {
      this.bot.sendMessage(msg.chat.id, `‚úÖ **Queue Cleared Successfully**\n\nüóëÔ∏è Action: QUEUE CLEARED\nüìã Items Removed: ${queueLength}\nüìù Cleared Numbers: [${oldQueue.join(', ')}]\nüìä New Queue Length: 0\nüë§ Cleared by: @${username}\n‚è∞ ${TimeUtils.getIndianTimeString()}`);
    } else {
      this.bot.sendMessage(msg.chat.id, `‚ÑπÔ∏è **Queue Already Empty**\n\nüìã Current Queue Length: 0\nüë§ Attempted by: @${username}\n\nThe queue was already empty.`);
    }
    
    await this.logAction(userId, username, 'clear_queue', 'Queue cleared', oldQueue, [], true);
  }

  /**
   * Log bot startup
   */
  private async logBotStart(): Promise<void> {
    console.log('ü§ñ Telegram Bot Service started');
    await this.logAction(0, 'System', 'bot_start', 'Telegram bot service started', null, null, true);
  }

  /**
   * Log action to audit system
   */
  private async logAction(
    userId: number,
    username: string,
    action: string,
    details: string,
    oldValue: any,
    newValue: any,
    success: boolean
  ): Promise<void> {
    await this.auditService.logAction({
      user_id: userId,
      username,
      action,
      details,
      old_value: oldValue,
      new_value: newValue,
      success
    });
  }
}
